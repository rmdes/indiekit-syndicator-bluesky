import { CID } from 'multiformats/cid';
export declare const DAG_CBOR_MULTICODEC = 113;
export type DAG_CBOR_MULTICODEC = typeof DAG_CBOR_MULTICODEC;
export declare const RAW_MULTICODEC = 85;
export type RAW_MULTICODEC = typeof RAW_MULTICODEC;
export declare const SHA256_MULTIHASH: 18;
export type SHA256_MULTIHASH = typeof SHA256_MULTIHASH;
export declare const SHA512_MULTIHASH: 19;
export type SHA512_MULTIHASH = typeof SHA512_MULTIHASH;
export interface Multihash<TCode extends number = number> {
    /**
     * Code of the multihash
     */
    code: TCode;
    /**
     * Raw digest
     */
    digest: Uint8Array;
}
export declare function multihashEquals(a: Multihash, b: Multihash): boolean;
declare module 'multiformats/cid' {
    /**
     * @deprecated use the {@link Cid} interface from `@atproto/lex-data`, and
     * related helpers ({@link isCid}, {@link ifCid}, {@link asCid},
     * {@link parseCid}, {@link decodeCid}), instead.
     *
     * This is marked as deprecated because we want to discourage direct usage of
     * `multiformats/cid` in dependent packages, and instead have them rely on the
     * {@link Cid} interface from `@atproto/lex-data`. The {@link CID} class from
     * `multiformats` version <10 has compatibility issues with certain TypeScript
     * configuration, which can lead to type errors in dependent packages.
     *
     * We are stuck with version 9 because `@atproto` packages did not drop
     * CommonJS support yet, and multiformats version 10 only supports ES modules.
     *
     * In order to avoid compatibility issues, while preparing for future breaking
     * changes (CID in multiformats v10+ has a slightly different interface), as
     * we update or swap out `multiformats`, `@atproto/lex-data` provides its own
     * stable {@link Cid} interface.
     */
    interface CID {
    }
}
export { /** @deprecated */ CID };
/**
 * Converts a {@link Cid} to a multiformats {@link CID} instance.
 *
 * @deprecated Packages depending on `@atproto/lex-data` should use the
 * {@link Cid} interface instead of relying on `multiformats`'s {@link CID}
 * implementation directly. This is to avoid compatibility issues, and in order
 * to allow better portability, compatibility and future updates.
 */
export declare function asMultiformatsCID<TVersion extends 0 | 1 = 0 | 1, TCode extends number = number, TMultihashCode extends number = number>(input: Cid<TVersion, TCode, TMultihashCode>): CID & Cid<TVersion, TCode, TMultihashCode>;
/**
 * Interface for working with CIDs
 */
export interface Cid<TVersion extends 0 | 1 = 0 | 1, TCode extends number = number, TMultihashCode extends number = number> {
    readonly version: TVersion;
    readonly code: TCode;
    readonly multihash: Multihash<TMultihashCode>;
    /**
     * Binary representation of the whole CID.
     */
    readonly bytes: Uint8Array;
    equals(other: Cid): boolean;
    toString(): string;
}
/**
 * Represents the cid of raw binary data (like media blobs).
 *
 * The use of {@link SHA256_MULTIHASH} is recommended but not required for raw CIDs.
 *
 * @see {@link https://atproto.com/specs/data-model#link-and-cid-formats ATproto Data Model - Link and CID Formats}
 */
export type RawCid = Cid<1, RAW_MULTICODEC>;
export declare function isRawCid(cid: Cid): cid is RawCid;
/**
 * Represents a DASL compliant CID.
 * @see {@link https://dasl.ing/cid.html DASL-CIDs}
 */
export type DaslCid = Cid<1, RAW_MULTICODEC | DAG_CBOR_MULTICODEC, SHA256_MULTIHASH>;
export declare function isDaslCid(cid: Cid): cid is DaslCid;
/**
 * Represents the cid of ATProto DAG-CBOR data (like repository MST nodes).
 * @see {@link https://atproto.com/specs/data-model#link-and-cid-formats ATproto Data Model - Link and CID Formats}
 */
export type CborCid = Cid<1, DAG_CBOR_MULTICODEC, SHA256_MULTIHASH>;
export declare function isCborCid(cid: Cid): cid is CborCid;
export type CheckCidOptions = {
    flavor?: 'raw' | 'cbor' | 'dasl';
};
export type InferCheckedCid<TOptions> = TOptions extends {
    flavor: 'raw';
} ? RawCid : TOptions extends {
    flavor: 'cbor';
} ? CborCid : Cid;
/**
 * Type guard to check whether a {@link Cid} instance meets specific flavor
 * constraints.
 */
export declare function checkCid<TOptions extends CheckCidOptions>(cid: Cid, options: TOptions): cid is InferCheckedCid<TOptions>;
export declare function checkCid(cid: Cid, options?: CheckCidOptions): boolean;
/**
 * Type guard to check whether a value is a valid {@link Cid} instance,
 * optionally checking for specific flavor constraints.
 */
export declare function isCid<TOptions extends CheckCidOptions>(value: unknown, options: TOptions): value is InferCheckedCid<TOptions>;
export declare function isCid(value: unknown, options?: CheckCidOptions): value is Cid;
/**
 * Returns the input value as a {@link Cid} if it is valid, or `null` otherwise.
 */
export declare function ifCid<TValue, TOptions extends CheckCidOptions>(value: unknown, options: TOptions): (TValue & InferCheckedCid<TOptions>) | null;
export declare function ifCid<TValue>(value: TValue, options?: CheckCidOptions): (TValue & Cid) | null;
/**
 * Returns the input value as a {@link Cid} if it is valid.
 *
 * @throws if the input is not a valid {@link Cid}.
 */
export declare function asCid<TValue, TOptions extends CheckCidOptions>(value: TValue, options: TOptions): TValue & InferCheckedCid<TOptions>;
export declare function asCid<TValue>(value: TValue, options?: CheckCidOptions): Cid & TValue;
/**
 * Decodes a CID from its binary representation.
 *
 * @see {@link https://dasl.ing/cid.html DASL-CIDs}
 * @throws if the input do not represent a valid DASL {@link Cid}
 */
export declare function decodeCid<TOptions extends CheckCidOptions>(cidBytes: Uint8Array, options: TOptions): InferCheckedCid<TOptions>;
export declare function decodeCid(cidBytes: Uint8Array, options?: CheckCidOptions): Cid;
/**
 * Parses a CID string into a Cid object.
 *
 * @throws if the input is not a valid CID string.
 */
export declare function parseCid<TOptions extends CheckCidOptions>(input: string, options: TOptions): InferCheckedCid<TOptions>;
export declare function parseCid(input: string, options?: CheckCidOptions): Cid;
export declare function validateCidString(input: string, options?: CheckCidOptions): boolean;
export declare function parseCidSafe<TOptions extends CheckCidOptions>(input: string, options: TOptions): InferCheckedCid<TOptions> | null;
export declare function parseCidSafe(input: string, options?: CheckCidOptions): Cid | null;
export declare function ensureValidCidString(input: string, options?: CheckCidOptions): void;
/**
 * Verifies whether the multihash of a given {@link cid} matches the hash of the provided {@link bytes}.
 * @params cid The CID to match against the bytes.
 * @params bytes The bytes to verify.
 * @returns true if the CID matches the bytes, false otherwise.
 */
export declare function isCidForBytes(cid: Cid, bytes: Uint8Array): Promise<boolean>;
export declare function createCid<TCode extends number, TMultihashCode extends number>(code: TCode, multihashCode: TMultihashCode, digest: Uint8Array): Cid<1, TCode, TMultihashCode>;
export declare function cidForCbor(bytes: Uint8Array): Promise<CborCid>;
export declare function cidForRawBytes(bytes: Uint8Array): Promise<RawCid>;
export declare function cidForRawHash(digest: Uint8Array): RawCid;
//# sourceMappingURL=cid.d.ts.map