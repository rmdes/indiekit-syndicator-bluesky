{"version":3,"file":"cid.js","sourceRoot":"","sources":["../src/cid.ts"],"names":[],"mappings":"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","sourcesContent":["import { CID } from 'multiformats/cid'\nimport { create as createDigest } from 'multiformats/hashes/digest'\nimport { sha256, sha512 } from 'multiformats/hashes/sha2'\nimport { isObject } from './object.js'\nimport { ui8Equals } from './uint8array.js'\n\nexport const DAG_CBOR_MULTICODEC = 0x71 // DRISL conformant DAG-CBOR\nexport type DAG_CBOR_MULTICODEC = typeof DAG_CBOR_MULTICODEC\n\nexport const RAW_MULTICODEC = 0x55 // raw binary codec used in DASL CIDs\nexport type RAW_MULTICODEC = typeof RAW_MULTICODEC\n\nexport const SHA256_MULTIHASH = sha256.code\nexport type SHA256_MULTIHASH = typeof SHA256_MULTIHASH\n\nexport const SHA512_MULTIHASH = sha512.code\nexport type SHA512_MULTIHASH = typeof SHA512_MULTIHASH\n\nexport interface Multihash<TCode extends number = number> {\n  /**\n   * Code of the multihash\n   */\n  code: TCode\n\n  /**\n   * Raw digest\n   */\n  digest: Uint8Array\n}\n\nexport function multihashEquals(a: Multihash, b: Multihash): boolean {\n  return a.code === b.code && ui8Equals(a.digest, b.digest)\n}\n\ndeclare module 'multiformats/cid' {\n  /**\n   * @deprecated use the {@link Cid} interface from `@atproto/lex-data`, and\n   * related helpers ({@link isCid}, {@link ifCid}, {@link asCid},\n   * {@link parseCid}, {@link decodeCid}), instead.\n   *\n   * This is marked as deprecated because we want to discourage direct usage of\n   * `multiformats/cid` in dependent packages, and instead have them rely on the\n   * {@link Cid} interface from `@atproto/lex-data`. The {@link CID} class from\n   * `multiformats` version <10 has compatibility issues with certain TypeScript\n   * configuration, which can lead to type errors in dependent packages.\n   *\n   * We are stuck with version 9 because `@atproto` packages did not drop\n   * CommonJS support yet, and multiformats version 10 only supports ES modules.\n   *\n   * In order to avoid compatibility issues, while preparing for future breaking\n   * changes (CID in multiformats v10+ has a slightly different interface), as\n   * we update or swap out `multiformats`, `@atproto/lex-data` provides its own\n   * stable {@link Cid} interface.\n   */\n  interface CID {}\n}\n\n// multiformats' CID class is not very portable because:\n//\n// - In dependent packages that use \"moduleResolution\" set to \"node16\",\n//   \"nodenext\" or \"bundler\", TypeScript fails to properly resolve the\n//   multiformats package when importing CID from @atproto/lex-data. This causes\n//   type errors in those packages. This is caused by the fact that the\n//   multiformats version <10 (which is the last version that supports CommonJS)\n//   uses \"exports\" field in package.json, which do not contain \"types\"\n//   entrypoints.\n//   https://www.npmjs.com/package/multiformats/v/9.9.0?activeTab=code\n// - By defining our own interface and helper functions, we can have more\n//   control over the public API exposed by this package.\n// - It allow us to have a stable interface in case we need to swap out, or\n//   eventually update multiformats (should we choose to drop CommonJS support)\n//   in the future.\n\n// @NOTE Even though it is not portable, we still re-export CID here so that\n// dependent packages where it can be used, have access to it (instead of\n// importing directly from \"multiformats\" or \"multiformats/cid\").\nexport { /** @deprecated */ CID }\n\n/**\n * Converts a {@link Cid} to a multiformats {@link CID} instance.\n *\n * @deprecated Packages depending on `@atproto/lex-data` should use the\n * {@link Cid} interface instead of relying on `multiformats`'s {@link CID}\n * implementation directly. This is to avoid compatibility issues, and in order\n * to allow better portability, compatibility and future updates.\n */\nexport function asMultiformatsCID<\n  TVersion extends 0 | 1 = 0 | 1,\n  TCode extends number = number,\n  TMultihashCode extends number = number,\n>(input: Cid<TVersion, TCode, TMultihashCode>) {\n  const cid =\n    // Already a multiformats CID instance\n    CID.asCID(input) ??\n    // Create a new multiformats CID instance\n    CID.create(\n      input.version,\n      input.code,\n      createDigest(input.multihash.code, input.multihash.digest),\n    )\n\n  // @NOTE: the \"satisfies\" operator is used here to ensure that the Cid\n  // interface is indeed compatible with multiformats' CID implementation, which\n  // allows us to safely rely on multiformats' CID implementation where Cid are\n  // needed.\n  return cid satisfies Cid as CID & Cid<TVersion, TCode, TMultihashCode>\n}\n\n/**\n * Interface for working with CIDs\n */\nexport interface Cid<\n  TVersion extends 0 | 1 = 0 | 1,\n  TCode extends number = number,\n  TMultihashCode extends number = number,\n> {\n  // @NOTE This interface is compatible with multiformats' CID implementation\n  // which we are using under the hood.\n\n  readonly version: TVersion\n  readonly code: TCode\n  readonly multihash: Multihash<TMultihashCode>\n\n  /**\n   * Binary representation of the whole CID.\n   */\n  readonly bytes: Uint8Array\n\n  equals(other: Cid): boolean\n  toString(): string\n}\n\n/**\n * Represents the cid of raw binary data (like media blobs).\n *\n * The use of {@link SHA256_MULTIHASH} is recommended but not required for raw CIDs.\n *\n * @see {@link https://atproto.com/specs/data-model#link-and-cid-formats ATproto Data Model - Link and CID Formats}\n */\nexport type RawCid = Cid<1, RAW_MULTICODEC>\n\nexport function isRawCid(cid: Cid): cid is RawCid {\n  return cid.version === 1 && cid.code === RAW_MULTICODEC\n}\n\n/**\n * Represents a DASL compliant CID.\n * @see {@link https://dasl.ing/cid.html DASL-CIDs}\n */\nexport type DaslCid = Cid<\n  1,\n  RAW_MULTICODEC | DAG_CBOR_MULTICODEC,\n  SHA256_MULTIHASH\n>\n\nexport function isDaslCid(cid: Cid): cid is DaslCid {\n  return (\n    cid.version === 1 &&\n    (cid.code === RAW_MULTICODEC || cid.code === DAG_CBOR_MULTICODEC) &&\n    cid.multihash.code === SHA256_MULTIHASH &&\n    cid.multihash.digest.byteLength === 32 // Should always be 32 bytes (256 bits) for SHA-256, but double-checking anyways\n  )\n}\n\n/**\n * Represents the cid of ATProto DAG-CBOR data (like repository MST nodes).\n * @see {@link https://atproto.com/specs/data-model#link-and-cid-formats ATproto Data Model - Link and CID Formats}\n */\nexport type CborCid = Cid<1, DAG_CBOR_MULTICODEC, SHA256_MULTIHASH>\n\nexport function isCborCid(cid: Cid): cid is CborCid {\n  return cid.code === DAG_CBOR_MULTICODEC && isDaslCid(cid)\n}\n\nexport type CheckCidOptions = {\n  flavor?: 'raw' | 'cbor' | 'dasl'\n}\n\nexport type InferCheckedCid<TOptions> = TOptions extends { flavor: 'raw' }\n  ? RawCid\n  : TOptions extends { flavor: 'cbor' }\n    ? CborCid\n    : Cid\n\n/**\n * Type guard to check whether a {@link Cid} instance meets specific flavor\n * constraints.\n */\nexport function checkCid<TOptions extends CheckCidOptions>(\n  cid: Cid,\n  options: TOptions,\n): cid is InferCheckedCid<TOptions>\nexport function checkCid(cid: Cid, options?: CheckCidOptions): boolean\nexport function checkCid(cid: Cid, options?: CheckCidOptions): boolean {\n  switch (options?.flavor) {\n    case undefined:\n      return true\n    case 'cbor':\n      return isCborCid(cid)\n    case 'dasl':\n      return isDaslCid(cid)\n    case 'raw':\n      return isRawCid(cid)\n    default:\n      throw new TypeError(`Unknown CID flavor: ${options?.flavor}`)\n  }\n}\n\n/**\n * Type guard to check whether a value is a valid {@link Cid} instance,\n * optionally checking for specific flavor constraints.\n */\nexport function isCid<TOptions extends CheckCidOptions>(\n  value: unknown,\n  options: TOptions,\n): value is InferCheckedCid<TOptions>\nexport function isCid(value: unknown, options?: CheckCidOptions): value is Cid\nexport function isCid(value: unknown, options?: CheckCidOptions): value is Cid {\n  return isCidImplementation(value) && checkCid(value, options)\n}\n\n/**\n * Returns the input value as a {@link Cid} if it is valid, or `null` otherwise.\n */\nexport function ifCid<TValue, TOptions extends CheckCidOptions>(\n  value: unknown,\n  options: TOptions,\n): (TValue & InferCheckedCid<TOptions>) | null\nexport function ifCid<TValue>(\n  value: TValue,\n  options?: CheckCidOptions,\n): (TValue & Cid) | null\nexport function ifCid(value: unknown, options?: CheckCidOptions): Cid | null {\n  if (isCidImplementation(value) && checkCid(value, options)) return value\n  return null\n}\n\n/**\n * Returns the input value as a {@link Cid} if it is valid.\n *\n * @throws if the input is not a valid {@link Cid}.\n */\nexport function asCid<TValue, TOptions extends CheckCidOptions>(\n  value: TValue,\n  options: TOptions,\n): TValue & InferCheckedCid<TOptions>\nexport function asCid<TValue>(\n  value: TValue,\n  options?: CheckCidOptions,\n): Cid & TValue\nexport function asCid(value: unknown, options?: CheckCidOptions): Cid {\n  if (isCidImplementation(value) && checkCid(value, options)) return value\n  throw new Error('Not a valid CID')\n}\n\n/**\n * Decodes a CID from its binary representation.\n *\n * @see {@link https://dasl.ing/cid.html DASL-CIDs}\n * @throws if the input do not represent a valid DASL {@link Cid}\n */\nexport function decodeCid<TOptions extends CheckCidOptions>(\n  cidBytes: Uint8Array,\n  options: TOptions,\n): InferCheckedCid<TOptions>\nexport function decodeCid(cidBytes: Uint8Array, options?: CheckCidOptions): Cid\nexport function decodeCid(\n  cidBytes: Uint8Array,\n  options?: CheckCidOptions,\n): Cid {\n  const cid = CID.decode(cidBytes)\n  return asCid(cid, options)\n}\n\n/**\n * Parses a CID string into a Cid object.\n *\n * @throws if the input is not a valid CID string.\n */\nexport function parseCid<TOptions extends CheckCidOptions>(\n  input: string,\n  options: TOptions,\n): InferCheckedCid<TOptions>\nexport function parseCid(input: string, options?: CheckCidOptions): Cid\nexport function parseCid(input: string, options?: CheckCidOptions): Cid {\n  const cid = CID.parse(input)\n  return asCid(cid, options)\n}\n\nexport function validateCidString(\n  input: string,\n  options?: CheckCidOptions,\n): boolean {\n  return parseCidSafe(input, options)?.toString() === input\n}\n\nexport function parseCidSafe<TOptions extends CheckCidOptions>(\n  input: string,\n  options: TOptions,\n): InferCheckedCid<TOptions> | null\nexport function parseCidSafe(\n  input: string,\n  options?: CheckCidOptions,\n): Cid | null\nexport function parseCidSafe(\n  input: string,\n  options?: CheckCidOptions,\n): Cid | null {\n  try {\n    return parseCid(input, options)\n  } catch {\n    return null\n  }\n}\n\nexport function ensureValidCidString(\n  input: string,\n  options?: CheckCidOptions,\n): void {\n  if (!validateCidString(input, options)) {\n    throw new Error(`Invalid CID string`)\n  }\n}\n\n/**\n * Verifies whether the multihash of a given {@link cid} matches the hash of the provided {@link bytes}.\n * @params cid The CID to match against the bytes.\n * @params bytes The bytes to verify.\n * @returns true if the CID matches the bytes, false otherwise.\n */\nexport async function isCidForBytes(\n  cid: Cid,\n  bytes: Uint8Array,\n): Promise<boolean> {\n  if (cid.multihash.code === sha256.code) {\n    const multihash = await sha256.digest(bytes)\n    return multihashEquals(multihash, cid.multihash)\n  }\n\n  if (cid.multihash.code === sha512.code) {\n    const multihash = await sha512.digest(bytes)\n    return multihashEquals(multihash, cid.multihash)\n  }\n\n  // Don't know how to verify other multihash codes\n  throw new Error('Unsupported CID multihash')\n}\n\nexport function createCid<TCode extends number, TMultihashCode extends number>(\n  code: TCode,\n  multihashCode: TMultihashCode,\n  digest: Uint8Array,\n) {\n  const cid: Cid = CID.createV1(code, createDigest(multihashCode, digest))\n  return cid as Cid<1, TCode, TMultihashCode>\n}\n\nexport async function cidForCbor(bytes: Uint8Array): Promise<CborCid> {\n  const multihash = await sha256.digest(bytes)\n  return CID.createV1(DAG_CBOR_MULTICODEC, multihash) as CborCid\n}\n\nexport async function cidForRawBytes(bytes: Uint8Array): Promise<RawCid> {\n  const multihash = await sha256.digest(bytes)\n  return CID.createV1(RAW_MULTICODEC, multihash) as RawCid\n}\n\nexport function cidForRawHash(digest: Uint8Array): RawCid {\n  // Fool-proofing\n  if (digest.length !== 32) {\n    throw new Error(`Invalid SHA-256 hash length: ${digest.length}`)\n  }\n  return createCid(RAW_MULTICODEC, sha256.code, digest)\n}\n\n/**\n * @internal\n */\nfunction isCidImplementation(value: unknown): value is Cid {\n  if (CID.asCID(value)) {\n    // CIDs created using older multiformats versions did not have a \"bytes\"\n    // property.\n    return (value as { bytes?: Uint8Array }).bytes != null\n  } else {\n    // Unknown implementation, do a structural check\n    try {\n      if (!isObject(value)) return false\n\n      const val = value as Record<string, unknown>\n      if (val.version !== 0 && val.version !== 1) return false\n      if (!isUint8(val.code)) return false\n\n      if (!isObject(val.multihash)) return false\n      const mh = val.multihash as Record<string, unknown>\n      if (!isUint8(mh.code)) return false\n      if (!(mh.digest instanceof Uint8Array)) return false\n\n      // Ensure that the bytes array is consistent with other properties\n      if (!(val.bytes instanceof Uint8Array)) return false\n      if (val.bytes[0] !== val.version) return false\n      if (val.bytes[1] !== val.code) return false\n      if (val.bytes[2] !== mh.code) return false\n      if (val.bytes[3] !== mh.digest.length) return false\n      if (val.bytes.length !== 4 + mh.digest.length) return false\n      if (!ui8Equals(val.bytes.subarray(4), mh.digest)) return false\n\n      if (typeof val.equals !== 'function') return false\n      if (val.equals(val) !== true) return false\n\n      return true\n    } catch {\n      return false\n    }\n  }\n}\n\n/**\n * @internal\n */\nfunction isUint8(val: unknown): val is number {\n  return Number.isInteger(val) && (val as number) >= 0 && (val as number) < 256\n}\n"]}