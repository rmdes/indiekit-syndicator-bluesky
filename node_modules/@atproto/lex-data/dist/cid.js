"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CID = exports.SHA512_MULTIHASH = exports.SHA256_MULTIHASH = exports.RAW_MULTICODEC = exports.DAG_CBOR_MULTICODEC = void 0;
exports.multihashEquals = multihashEquals;
exports.asMultiformatsCID = asMultiformatsCID;
exports.isRawCid = isRawCid;
exports.isDaslCid = isDaslCid;
exports.isCborCid = isCborCid;
exports.checkCid = checkCid;
exports.isCid = isCid;
exports.ifCid = ifCid;
exports.asCid = asCid;
exports.decodeCid = decodeCid;
exports.parseCid = parseCid;
exports.validateCidString = validateCidString;
exports.parseCidSafe = parseCidSafe;
exports.ensureValidCidString = ensureValidCidString;
exports.isCidForBytes = isCidForBytes;
exports.createCid = createCid;
exports.cidForCbor = cidForCbor;
exports.cidForRawBytes = cidForRawBytes;
exports.cidForRawHash = cidForRawHash;
const cid_1 = require("multiformats/cid");
Object.defineProperty(exports, "CID", { enumerable: true, get: function () { return cid_1.CID; } });
const digest_1 = require("multiformats/hashes/digest");
const sha2_1 = require("multiformats/hashes/sha2");
const object_js_1 = require("./object.js");
const uint8array_js_1 = require("./uint8array.js");
exports.DAG_CBOR_MULTICODEC = 0x71; // DRISL conformant DAG-CBOR
exports.RAW_MULTICODEC = 0x55; // raw binary codec used in DASL CIDs
exports.SHA256_MULTIHASH = sha2_1.sha256.code;
exports.SHA512_MULTIHASH = sha2_1.sha512.code;
function multihashEquals(a, b) {
    return a.code === b.code && (0, uint8array_js_1.ui8Equals)(a.digest, b.digest);
}
/**
 * Converts a {@link Cid} to a multiformats {@link CID} instance.
 *
 * @deprecated Packages depending on `@atproto/lex-data` should use the
 * {@link Cid} interface instead of relying on `multiformats`'s {@link CID}
 * implementation directly. This is to avoid compatibility issues, and in order
 * to allow better portability, compatibility and future updates.
 */
function asMultiformatsCID(input) {
    const cid = 
    // Already a multiformats CID instance
    cid_1.CID.asCID(input) ??
        // Create a new multiformats CID instance
        cid_1.CID.create(input.version, input.code, (0, digest_1.create)(input.multihash.code, input.multihash.digest));
    // @NOTE: the "satisfies" operator is used here to ensure that the Cid
    // interface is indeed compatible with multiformats' CID implementation, which
    // allows us to safely rely on multiformats' CID implementation where Cid are
    // needed.
    return cid;
}
function isRawCid(cid) {
    return cid.version === 1 && cid.code === exports.RAW_MULTICODEC;
}
function isDaslCid(cid) {
    return (cid.version === 1 &&
        (cid.code === exports.RAW_MULTICODEC || cid.code === exports.DAG_CBOR_MULTICODEC) &&
        cid.multihash.code === exports.SHA256_MULTIHASH &&
        cid.multihash.digest.byteLength === 32 // Should always be 32 bytes (256 bits) for SHA-256, but double-checking anyways
    );
}
function isCborCid(cid) {
    return cid.code === exports.DAG_CBOR_MULTICODEC && isDaslCid(cid);
}
function checkCid(cid, options) {
    switch (options?.flavor) {
        case undefined:
            return true;
        case 'cbor':
            return isCborCid(cid);
        case 'dasl':
            return isDaslCid(cid);
        case 'raw':
            return isRawCid(cid);
        default:
            throw new TypeError(`Unknown CID flavor: ${options?.flavor}`);
    }
}
function isCid(value, options) {
    return isCidImplementation(value) && checkCid(value, options);
}
function ifCid(value, options) {
    if (isCidImplementation(value) && checkCid(value, options))
        return value;
    return null;
}
function asCid(value, options) {
    if (isCidImplementation(value) && checkCid(value, options))
        return value;
    throw new Error('Not a valid CID');
}
function decodeCid(cidBytes, options) {
    const cid = cid_1.CID.decode(cidBytes);
    return asCid(cid, options);
}
function parseCid(input, options) {
    const cid = cid_1.CID.parse(input);
    return asCid(cid, options);
}
function validateCidString(input, options) {
    return parseCidSafe(input, options)?.toString() === input;
}
function parseCidSafe(input, options) {
    try {
        return parseCid(input, options);
    }
    catch {
        return null;
    }
}
function ensureValidCidString(input, options) {
    if (!validateCidString(input, options)) {
        throw new Error(`Invalid CID string`);
    }
}
/**
 * Verifies whether the multihash of a given {@link cid} matches the hash of the provided {@link bytes}.
 * @params cid The CID to match against the bytes.
 * @params bytes The bytes to verify.
 * @returns true if the CID matches the bytes, false otherwise.
 */
async function isCidForBytes(cid, bytes) {
    if (cid.multihash.code === sha2_1.sha256.code) {
        const multihash = await sha2_1.sha256.digest(bytes);
        return multihashEquals(multihash, cid.multihash);
    }
    if (cid.multihash.code === sha2_1.sha512.code) {
        const multihash = await sha2_1.sha512.digest(bytes);
        return multihashEquals(multihash, cid.multihash);
    }
    // Don't know how to verify other multihash codes
    throw new Error('Unsupported CID multihash');
}
function createCid(code, multihashCode, digest) {
    const cid = cid_1.CID.createV1(code, (0, digest_1.create)(multihashCode, digest));
    return cid;
}
async function cidForCbor(bytes) {
    const multihash = await sha2_1.sha256.digest(bytes);
    return cid_1.CID.createV1(exports.DAG_CBOR_MULTICODEC, multihash);
}
async function cidForRawBytes(bytes) {
    const multihash = await sha2_1.sha256.digest(bytes);
    return cid_1.CID.createV1(exports.RAW_MULTICODEC, multihash);
}
function cidForRawHash(digest) {
    // Fool-proofing
    if (digest.length !== 32) {
        throw new Error(`Invalid SHA-256 hash length: ${digest.length}`);
    }
    return createCid(exports.RAW_MULTICODEC, sha2_1.sha256.code, digest);
}
/**
 * @internal
 */
function isCidImplementation(value) {
    if (cid_1.CID.asCID(value)) {
        // CIDs created using older multiformats versions did not have a "bytes"
        // property.
        return value.bytes != null;
    }
    else {
        // Unknown implementation, do a structural check
        try {
            if (!(0, object_js_1.isObject)(value))
                return false;
            const val = value;
            if (val.version !== 0 && val.version !== 1)
                return false;
            if (!isUint8(val.code))
                return false;
            if (!(0, object_js_1.isObject)(val.multihash))
                return false;
            const mh = val.multihash;
            if (!isUint8(mh.code))
                return false;
            if (!(mh.digest instanceof Uint8Array))
                return false;
            // Ensure that the bytes array is consistent with other properties
            if (!(val.bytes instanceof Uint8Array))
                return false;
            if (val.bytes[0] !== val.version)
                return false;
            if (val.bytes[1] !== val.code)
                return false;
            if (val.bytes[2] !== mh.code)
                return false;
            if (val.bytes[3] !== mh.digest.length)
                return false;
            if (val.bytes.length !== 4 + mh.digest.length)
                return false;
            if (!(0, uint8array_js_1.ui8Equals)(val.bytes.subarray(4), mh.digest))
                return false;
            if (typeof val.equals !== 'function')
                return false;
            if (val.equals(val) !== true)
                return false;
            return true;
        }
        catch {
            return false;
        }
    }
}
/**
 * @internal
 */
function isUint8(val) {
    return Number.isInteger(val) && val >= 0 && val < 256;
}
//# sourceMappingURL=cid.js.map