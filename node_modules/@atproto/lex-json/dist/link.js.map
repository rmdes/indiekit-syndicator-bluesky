{"version":3,"file":"link.js","sourceRoot":"","sources":["../src/link.ts"],"names":[],"mappings":";;AAgBA,oCAkCC;AAED,sCAEC;AAtDD,gDAK0B;AAW1B,SAAgB,YAAY,CAC1B,KAA+B,EAC/B,OAAyB;IAEzB,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,OAAO,IAAI,KAAK,CAAC,EAAE,CAAC;QAClC,OAAO,SAAS,CAAA;IAClB,CAAC;IAED,KAAK,MAAM,GAAG,IAAI,KAAK,EAAE,CAAC;QACxB,IAAI,GAAG,KAAK,OAAO,EAAE,CAAC;YACpB,OAAO,SAAS,CAAA;QAClB,CAAC;IACH,CAAC;IAED,MAAM,EAAE,KAAK,EAAE,GAAG,KAAK,CAAA;IAEvB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,MAAM,IAAI,SAAS,CAAC,2CAA2C,CAAC,CAAA;IAClE,CAAC;IAED,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACvB,MAAM,IAAI,SAAS,CAAC,qCAAqC,CAAC,CAAA;IAC5D,CAAC;IAED,yDAAyD;IACzD,IAAI,KAAK,CAAC,MAAM,GAAG,IAAI,EAAE,CAAC;QACxB,MAAM,IAAI,SAAS,CAAC,iCAAiC,CAAC,CAAA;IACxD,CAAC;IAED,IAAI,CAAC;QACH,OAAO,IAAA,mBAAQ,EAAC,KAAK,EAAE,OAAO,CAAC,CAAA;IACjC,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,IAAI,SAAS,CAAC,6BAA6B,EAAE,EAAE,KAAK,EAAE,CAAC,CAAA;IAC/D,CAAC;AACH,CAAC;AAED,SAAgB,aAAa,CAAC,GAAQ;IACpC,OAAO,EAAE,KAAK,EAAE,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAA;AAClC,CAAC","sourcesContent":["import {\n  CheckCidOptions,\n  Cid,\n  InferCheckedCid,\n  parseCid,\n} from '@atproto/lex-data'\nimport { JsonValue } from './json.js'\n\nexport function parseLexLink<TOptions extends CheckCidOptions>(\n  input: undefined | Record<string, unknown>,\n  options: TOptions,\n): InferCheckedCid<TOptions> | undefined\nexport function parseLexLink(\n  input?: Record<string, unknown>,\n  options?: CheckCidOptions,\n): Cid | undefined\nexport function parseLexLink(\n  input?: Record<string, unknown>,\n  options?: CheckCidOptions,\n): Cid | undefined {\n  if (!input || !('$link' in input)) {\n    return undefined\n  }\n\n  for (const key in input) {\n    if (key !== '$link') {\n      return undefined\n    }\n  }\n\n  const { $link } = input\n\n  if (typeof $link !== 'string') {\n    throw new TypeError('$link must be a base32-encoded CID string')\n  }\n\n  if ($link.length === 0) {\n    throw new TypeError('CID string in $link cannot be empty')\n  }\n\n  // Arbitrary limit to prevent DoS via extremely long CIDs\n  if ($link.length > 2048) {\n    throw new TypeError('CID string in $link is too long')\n  }\n\n  try {\n    return parseCid($link, options)\n  } catch (cause) {\n    throw new TypeError('Invalid CID string in $link', { cause })\n  }\n}\n\nexport function encodeLexLink(cid: Cid): JsonValue {\n  return { $link: cid.toString() }\n}\n"]}